---
output: github_document
bibliography: "README-references.bib"
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-",
  out.width = "100%"
)
```

<div align="center">

<table>
<tr>
  <!-- Imagen izquierda -->
  <td><img src="WETSAT-ML_icon.png" alt="Logo WetSAT-ML" width="120"></td>
  
  <!-- Texto central -->
  <td align="center" style="vertical-align: middle; padding-left: 18px; padding-right: 18px; text-align: center;">
  
    <!-- Título en Markdown dentro del HTML -->
    <h1 style="margin-bottom: 6px; text-align: center;">WetSAT-ML</h1>

    <!-- Frase original abajo -->
    <span style="font-size: 18px;">
      <strong>W</strong>etlands flooding <strong>e</strong>xtent and <strong>t</strong>rends using 
      <strong>SAT</strong>ellite data and <strong>M</strong>achine <strong>L</strong>earning
    </span>
  </td>

  <!-- Imagen derecha -->
  <td><img src="LOGO_SEI.png" alt="Logo SEI" width="120"></td>
</tr>
</table>

</div>

## Methodology

WetSAT-ML (Wetlands flooding extent and trends using SATellite data and Machine Learning) is an open-source R package developed by SEI Latin America.
It enables monitoring of wetland flooding dynamics using Sentinel-1 radar imagery combined with machine learning algorithms.

The tool integrates with Google Earth Engine and allows users to:

* Generate wetland flooding extent maps.
* Produce water permanence maps.
* Extract flooded area time series.
* Quantify intra-annual and inter-annual wetland hydrological trends. 

```{r rstudio-create-pkg2, echo = FALSE, fig.align = "left", fig.cap = "Figure 1. WetSAT-ML methodology workflow for generating wetland flooding extent and trends using Sentinel-1 data and machine learning."}
knitr::include_graphics("Methodology.png", dpi = 200)
```

## Concepts behind the WetSAT-ML tool
WetSAT-ML uses Sentinel-1 Synthetic Aperture Radar (SAR) data to map water extent, overcoming the limitations of optical data, which often fail in cloudy or dense vegetation conditions.

The algorithm combines radar backscatter from VV and VH polarizations with five radar-derived indices:

| Index | Formula |
|-------|--------|
| **PR - Polarized Ratio**   | σ<sub>VH</sub><sup>0</sup> / σ<sub>VV</sub><sup>0</sup> |
| **NDPI - Normalized Difference Polarized Index** | (σ<sub>VV</sub><sup>0</sup> − σ<sub>VH</sub><sup>0</sup>) / (σ<sub>VV</sub><sup>0</sup> + σ<sub>VH</sub><sup>0</sup>) |
| **NVHI - Normalized VH Index** | σ<sub>VH</sub><sup>0</sup> / (σ<sub>VV</sub><sup>0</sup> + σ<sub>VH</sub><sup>0</sup>) |
| **NVVI - Normalized VV Index** | σ<sub>VV</sub><sup>0</sup> / (σ<sub>VV</sub><sup>0</sup> + σ<sub>VH</sub><sup>0</sup>) |
| **RVI - Radar Vegetation Index** | 4 · σ<sub>VH</sub><sup>0</sup> / (σ<sub>VV</sub><sup>0</sup> + σ<sub>VH</sub><sup>0</sup>) |

These indices characterize the scattering behavior of radar signals under different wetland flooding conditions, enabling pixel-level water detection.

## Tool functions
The WetSAT-ML package contains four main functions. Each function has practical examples of usage within the documentation:

| Function                     | Description                                                                                                                                                                    |
| ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`radar_index_stack`**      | Calculates radar-derived indices (PR, NDPI, NVHI, NVVI, RVI) from Sentinel-1 VV and VH backscatter and extracts median index values within a buffer around reference stations. |
| **`train_rf_model`**         | Trains a Random Forest classifier using radar-derived indices to detect water presence. Returns the trained model, overall accuracy, and variable importance.              |
| **`classify_water_surface`** | Applies the trained Random Forest model to classify water and non-water pixels at the image level. Produces wetland flooding maps and water permanence layers.         |
| **`performWS`**              | Generates time series of flooded areas, intra-annual and inter-annual flooding trends, and hydroperiod statistics.                                                             |

```{r eval=FALSE, include=TRUE}

```

## Installation

You can install the development version of WetSAT-ML from GitHub:

```{r eval=FALSE, include=TRUE}
# install.packages("devtools")
# devtools::install_github("dazamora/WETSAT")
```

## Dataset
The Everglades region is located in southern Florida, and it extends over an area of 9,150 km2 from the margin of Florida Bay in the south to the Everglades Agricultural Area (EAA) in the north (Figure 1). The area supports a diverse mosaic of different wetlands, including freshwater marshes, swamps, sloughs, and wet prairies (Figure 1a). The area also presents diverse vegetation communities where the sawgrass (especially Cladium jamaicense) is the most abundant, interspersed with patches of shrubs with a mix of swamp and bayhead shrub species, and trees with a mix of swamp, hammock, and bayhead tree species *@palomino2024*.

```{r rstudio-create-pkg3, out.width="50%", out.height="50%", fig.align = "center", echo = FALSE}
knitr::include_graphics("Study_area.png", dpi = 200)

```

## Example

This is a basic example which shows you how to solve a common problem:

```{r example}

## basic example code
```

What is special about using `README.Rmd` instead of just `README.md`? You can include R chunks like so:

```{r cars}
summary(cars)
```

You'll still need to render `README.Rmd` regularly, to keep `README.md` up-to-date. `devtools::build_readme()` is handy for this.

You can also embed plots, for example:

```{r pressure, echo = FALSE}
# plot(pressure)
```

## Datasets
```{r fig.2, echo=FALSE, fig.align= "center", fig.height=1, fig.width=6, dpi = 600}
par(mar=c(0.6,0.6,0.6,0.6)+0.1)
plot(0,0, yaxt = "n", xaxt = "n", type = "n",bty= "n", ylab = "", xlab = "")
text(0,0, labels = expression(italic(paste(frac("ET","P")," = ", "1 + ", frac("PET","P"), 
                                           " - ", bgroup("[",1 - bgroup("(",frac("PET", "P"), ")")^(frac(1,1+alpha)), "]")^(1+alpha), "  [eq.2]", sep =""))), 
     cex = 0.9)
```

## Disclaimer


## References


